import json
import os
from ..immergas.const import IM_LABEL, IM_MESSAGE, IM_MODE

# Load `immergas_registers.json` (generated by the extractor) and produce
# simple mappings for sensors/numbers/switches/selects/binary_sensors/climate
# The module builds these dicts at import-time so other platform modules
# can import them and use their defaults when defining components.

ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..', '..'))
REG_PATH = os.path.join(ROOT, 'immergas_registers.json')

def _safe_get(d, *keys, default=None):
    v = d
    try:
        for k in keys:
            v = v[k]
    except Exception:
        return default
    return v

sensors = {}
numbers = {}
switches = {}
selects = {}
binary_sensors = {}
climate = {}

if os.path.exists(REG_PATH):
    with open(REG_PATH, 'r', encoding='utf-8') as fh:
        data = json.load(fh)
    for entry in data.get('pdus', []):
        pid = entry.get('pdu')
        # process views
        for view in entry.get('views', []):
            item = view.get('item') or f"pdu_{pid}"
            label = view.get('label-en') or view.get('label-it') or item
            defaults = {}
            if view.get('step') is not None:
                defaults['step'] = view.get('step')
            if view.get('min') is not None:
                defaults['min'] = view.get('min')
            if view.get('max') is not None:
                defaults['max'] = view.get('max')

            # Weekday/calendar PDUs (u16 arrays) -> treat as numbers for now
            if item and 'weekday' in item:
                numbers[pid] = {IM_LABEL: label, IM_MESSAGE: pid, 'defaults': defaults}
                continue

            rtn = view.get('return')
            if rtn:
                # simple heuristic classification
                if isinstance(rtn, list) and 'temp' in rtn:
                    sensors[pid] = {IM_LABEL: label, IM_MESSAGE: pid, IM_MODE: 'STATUS', 'defaults': defaults}
                elif isinstance(rtn, list) and rtn[0] in ('LB', 'u8', 'u16', 's16'):
                    # if view defines on/off in 'value' treat as binary
                    val = view.get('value') or []
                    if any(str(v).lower() in ('on', 'off') for v in val):
                        binary_sensors[pid] = {IM_LABEL: label, IM_MESSAGE: pid, IM_MODE: 'STATUS', 'defaults': defaults}
                    else:
                        sensors[pid] = {IM_LABEL: label, IM_MESSAGE: pid, IM_MODE: 'STATUS', 'defaults': defaults}
                else:
                    sensors[pid] = {IM_LABEL: label, IM_MESSAGE: pid, IM_MODE: 'STATUS', 'defaults': defaults}

        # process commands -> writeable entities (numbers / switches)
        for cmd in entry.get('commands', []):
            citem = cmd.get('item') or f"pdu_{pid}"
            # 'data' contains tuples like [ ["temp", "mb-room-temp-set"] ]
            for data_item in cmd.get('data', []):
                if isinstance(data_item, list) and data_item:
                    dt = data_item[0]
                    label = cmd.get('label-en') or citem
                    defaults = {}
                    if dt == 'temp' or (isinstance(dt, str) and 'temp' in dt):
                        numbers[pid] = {IM_LABEL: label, IM_MESSAGE: pid, IM_MODE: 'CONTROL', 'defaults': defaults}
                    elif dt in ('LB', 'u8'):
                        switches[pid] = {IM_LABEL: label, IM_MESSAGE: pid, IM_MODE: 'CONTROL', 'defaults': defaults}

# exported names
__all__ = [
    'sensors',
    'numbers',
    'switches',
    'selects',
    'binary_sensors',
    'climate',
]
